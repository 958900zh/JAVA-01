执行GCLogAnalysis

执行时间：5s

生成对象次数结果如下：

|            | 512M  | 1G    | 2G    | 4G    |
| ---------- | ----- | ----- | ----- | ----- |
| SerialGC   | 42989 | 86122 | 77752 | 76103 |
| ParallelGC | 22979 | 77378 | 88611 | 99580 |
| CMS        | 39911 | 95811 | 91718 | 76196 |
| G1         | 31376 | 83374 | 87003 | 75851 |

执行gateway-server-0.0.1-SNAPSHOT.jar

压测命令wrk -c 50 -d 10 http://localhost:8088/api/hello

| 512M       | QPS      | GC次数 | 停顿时间 |
| ---------- | -------- | ------ | -------- |
| SerialGC   | 55051.32 | 104    | 239ms    |
| ParallelGC | 56900.82 | 112    | 189ms    |
| CMS        | 53563.56 | 101    | 316ms    |
| G1         | 52933.27 | 44     | 89ms     |

| 1G         | QPS      | GC次数 | 停顿时间 |
| ---------- | -------- | ------ | -------- |
| SerialGC   | 57671.18 | 54     | 132ms    |
| ParallelGC | 53558.01 | 52     | 94ms     |
| CMS        | 51185.62 | 47     | 190ms    |
| G1         | 52623.28 | 22     | 43ms     |

| 2G         | QPS      | GC次数 | 停顿时间 |
| ---------- | -------- | ------ | -------- |
| SerialGC   | 61232.66 | 28     | 65ms     |
| ParallelGC | 59221.36 | 30     | 50ms     |
| CMS        | 54616.43 | 26     | 121ms    |
| G1         | 52591.31 | 11     | 28ms     |

> **总结** 通过执行GCLogAnalysis，我们可以看到，在内存低于1G的情况下，SerialGC的效率还是不错的，但是当内存逐渐增大后，单线程的弊端就展现出来了。ParallelGC会随着内存的增加，生成对象的数量也是增加的，符合吞吐量优先的设计。而CMS和G1，当内存增长到一定程度之后，会随着内存的增加，吞吐量有所下降，从测试gateway-server的结果来看，尤其是G1的结果，停顿时间的表现是很优秀的。
>
> 分析执行gateway-server-0.0.1-SNAPSHOT.jar的结果，所有的收集器都会随着内存的增加，GC次数和停顿时间都是线性下降的趋势，QPS会随着停顿时间的减少而有少量的增加，SerialGC和ParallelGC的表现尤为明显。结合上次作业的压测结果，CMS的停顿时间依然是有些奇怪的，G1也是一如既往的稳定。
>
> **本次实验的总结** 在JDK1.8的环境中，收集器的选择可以从Parallel和G1二选一，如果要吞吐量就选Parallel，如果更关注停顿时间就用G1。（如果有条件的话，生产环境还是需要通过更详细的压测来做选择）